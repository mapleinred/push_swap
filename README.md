# push_swap

## Project Overview

**Push Swap** is a sorting algorithm challenge where you must sort a stack of integers using a limited set of operations and the fewest possible moves. The goal is to write a C program called `push_swap` that calculates and displays the optimal sequence of operations to sort the stack.

---

## Introduction to Linked Lists in C

A **linked list** is a fundamental data structure in C that consists of nodes, where each node contains data and a pointer to the next node in the sequence. Unlike arrays, linked lists allow efficient insertion and deletion of elements without reallocating or reorganizing the entire structure.

In this project, stacks are implemented as singly linked lists. Each node typically contains:
- An integer value (the data to be sorted)
- An index (used for sorting logic)
- A pointer to the next node

**Advantages of using linked lists:**
- Dynamic size: Nodes can be added or removed at runtime.
- Efficient insertions/deletions: Especially at the beginning of the list (the stack's top).

**Example of a simple node structure in C:**
```c
typedef struct s_node {
    int             value;
    int             index;
    struct s_node   *next;
} t_node;
```
The stack itself can be represented as a structure holding a pointer to the top node and the current size.

---

## Key Requirements

- **Input:** A list of integers passed as arguments.
- **Output:** A sequence of operations to sort the stack in ascending order.
- **Constraints:**
  - Only certain stack operations are allowed (see below).
  - The solution must be optimized for the fewest operations.
  - Handle errors (non-integer inputs, duplicates, or values outside the integer range).

---

## Allowed Operations

- `sa`, `sb`, `ss`: Swap the top two elements of stack A, stack B, or both.
- `pa`, `pb`: Push the top element from one stack to another.
- `ra`, `rb`, `rr`: Rotate the stack upward (shift all elements up by one).
- `rra`, `rrb`, `rrr`: Rotate the stack downward (shift all elements down by one).

---

## Implementation Details

### Data Structures

- **Stacks:** Implemented using a linked list (`t_stack` and `t_node` structures).
  - Each node holds an integer value, an index (for sorting), and a pointer to the next node.
  - The stack tracks the top node and its size.

### Algorithm Used

- **Small Stacks (2-3 elements):**
  - 2 elements: Swap if needed (`sa`).
  - 3 elements: Use simple sorting logic with swaps and rotations.

- **Medium Stacks (4-7 elements):**
  - **Insertion Sort:**
    - Push the smallest elements to stack B one by one.
    - Sort the remaining elements in stack A.
    - Push elements back from stack B to stack A in order.

- **Large Stacks (8+ elements):**
  - **Divide and Conquer:**
    - Split the stack into chunks based on the square root of the stack size.
    - Push elements to stack B in chunks, keeping track of their ranges.
    - Sort stack B and push elements back to stack A in ascending order.

### Key Functions

- **Parsing and Validation:**
  - `cdigits`: Counts and validates digits in input arguments.
  - `crange`: Checks if numbers are within integer limits.
  - `cduplicates`: Ensures no duplicates exist in the input.

- **Stack Operations:**
  - `swap`, `push`, `rotate`, `reverse_rotate`: Implement the basic stack operations.
  - `issorted`: Checks if the stack is already sorted.

- **Sorting Logic:**
  - `simple_sort`: Handles small stacks.
  - `insertionsort`: Sorts medium stacks.
  - `sort1` and `sort2`: Handle large stacks by dividing into chunks and merging.

---

## Error Handling

- Displays `"Error\n"` for invalid inputs (non-integers, duplicates, or out-of-range values).
- Frees allocated memory before exiting in case of errors.

---

## Learning Outcomes

- **Algorithm Optimization:** Evaluated and implemented different sorting algorithms based on input size.
- **Data Structures:** Gained hands-on experience with linked lists and stack operations.
- **Error Handling:** Improved skills in validating inputs and handling edge cases.
- **Complexity Analysis:** Practiced analyzing and optimizing algorithm complexity.
- **Project Management:** Developed a structured approach to breaking down the problem.

---

## How to Run the Project

### Compilation

```bash
make
```

### Example

```bash
$ ./push_swap 5 3 8 1 2
sa
ra
pb
pa
```

---

## How the Checker Works

The `checker` program is built as a bonus target in the Makefile using the variable `NAME_B = checker`. When you run:

```bash
make bonus
```

It is compiled from `checker.c` and related sources. The purpose of `checker` is to validate whether a sequence of operations (typically generated by `push_swap`) correctly sorts the stack.

**How it works:**
- `checker` takes the same list of integers as arguments as `push_swap`.
- It reads a sequence of operations from standard input (usually piped from `push_swap`).
- Each operation is applied step by step to the stacks.
- After all operations, it checks if stack A is sorted in ascending order and stack B is empty.
  - If sorted: outputs `OK`
  - If not sorted: outputs `KO`
  - If an invalid operation is encountered: outputs `Error`

---

## How to Use the Checker

### Compilation

To build the checker program, run:
```bash
make bonus
```

### Usage

You can use `checker` by piping the output of `push_swap` into it:

```bash
./push_swap <list_of_integers> | ./checker <list_of_integers>
```

**Example:**
```bash
./push_swap 3 1 2 | ./checker 3 1 2
```
**Output:**
```
OK
```

If the operations do not sort the stack, the output will be:
```
KO
```

If an invalid operation is provided, the output will be:
```
Error
```

---

## Notes

- Ensure to handle memory allocation and deallocation properly to avoid leaks.
- Optimize the algorithm to minimize the number of operations for sorting.
- Consider edge cases and test the program with various input scenarios.

---

## References

- [Sorting Algorithms - GeeksforGeeks](https://www.geeksforgeeks.org/sorting-algorithms/)
- [C Programming Language - Kernighan and Ritchie](https://en.wikipedia.org/wiki/The_C_Programming_Language)

---

## Conclusion

The Push Swap project was an excellent exercise in algorithm design, optimization, and problem-solving. It reinforced the importance of choosing the right algorithm for the right problem size and the value of careful error handling. The project also deepened my understanding of stack operations and linked list manipulations in C.